const { Gateway, Wallets } = require("fabric-network");
const path = require("path");
const fs = require("fs");

async function connectToFabric() {
  // Prefer an existing connection profile generated by the test-network
  const ccpPath = path.resolve(
    __dirname,
    "../../fabric-network/test-network/organizations/peerOrganizations/org1.example.com/connection-org1.json"
  );

  let ccp = null;
  if (fs.existsSync(ccpPath)) {
    try {
      ccp = JSON.parse(fs.readFileSync(ccpPath, "utf8"));
    } catch (e) {
      throw new Error(`Failed to parse connection profile at ${ccpPath}: ${e.message}`);
    }
  } else {
    // Build a minimal programmatic connection profile for local test network
    // Uses localhost endpoints and the peer TLS cert present in the test-network
    // Attempt to locate TLS certs generated by the test-network. If not present
    // fall back to non-TLS endpoints (grpc/http) so local dev can still proceed
    // when the test-network artifacts haven't been created in this workspace.
    const peerTlsPath = path.resolve(
      __dirname,
      "../../fabric-network/test-network/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt"
    );
    const ordererTlsPath = path.resolve(
      __dirname,
      "../../fabric-network/test-network/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/tls/ca.crt"
    );
    const caTlsPath = path.resolve(
      __dirname,
      "../../fabric-network/test-network/organizations/peerOrganizations/org1.example.com/ca/ca.org1.example.com-cert.pem"
    );

    const peerTlsCert = fs.existsSync(peerTlsPath) ? fs.readFileSync(peerTlsPath, "utf8") : null;
    const ordererTlsCert = fs.existsSync(ordererTlsPath) ? fs.readFileSync(ordererTlsPath, "utf8") : null;
    const caTlsCert = fs.existsSync(caTlsPath) ? fs.readFileSync(caTlsPath, "utf8") : null;

    const peerUrl = peerTlsCert ? "grpcs://localhost:7051" : "grpc://localhost:7051";
    const ordererUrl = ordererTlsCert ? "grpcs://localhost:7050" : "grpc://localhost:7050";
    const caUrl = caTlsCert ? "https://localhost:7054" : "http://localhost:7054";

    ccp = {
      name: "unitap-network",
      version: "1.0",
      client: {
        organization: "Org1MSP"
      },
      organizations: {
        Org1MSP: {
          mspid: "Org1MSP",
          peers: ["peer0.org1.example.com"],
          certificateAuthorities: ["ca.org1.example.com"]
        }
      },
      peers: {
        "peer0.org1.example.com": {
          url: peerUrl,
          tlsCACerts: peerTlsCert ? { pem: peerTlsCert } : undefined,
          grpcOptions: { "ssl-target-name-override": "peer0.org1.example.com", "hostnameOverride": "peer0.org1.example.com" }
        }
      },
      orderers: {
        "orderer.example.com": {
          url: ordererUrl,
          tlsCACerts: ordererTlsCert ? { pem: ordererTlsCert } : undefined
        }
      },
      certificateAuthorities: {
        "ca.org1.example.com": {
          url: caUrl,
          caName: "ca-org1",
          tlsCACerts: caTlsCert ? { pem: caTlsCert } : undefined
        }
      }
    };
  }

  // Wallet location: use backend/wallet by default (populateWallet writes there)
  const walletPath = process.env.WALLET_PATH || path.join(__dirname, '..', 'wallet');
  const wallet = await Wallets.newFileSystemWallet(walletPath);

  const identityExists = await wallet.get("admin");
  if (!identityExists) {
    throw new Error(
      `Admin identity not found in wallet at ${walletPath}. Run populateWallet.js to import the admin identity before connecting.`
    );
  }

  const gateway = new Gateway();

  await gateway.connect(ccp, {
    wallet,
    identity: "admin",
    discovery: { enabled: true, asLocalhost: true }
  });

  const network = await gateway.getNetwork(process.env.CHANNEL || "mychannel");
  const contract = network.getContract(process.env.CHAINCODE_NAME || "unitapcc");

  return { gateway, contract };
}

module.exports = connectToFabric;
